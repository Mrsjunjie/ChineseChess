# ChineseChess
  中国象棋
  
  3.1 比较局面的方法
　　在写中国象棋程序时，需要比较两个局面看它们是否相同。如果比较每个棋子的位置，或许不需要花很多时间，但是实战中每秒种需要做成千上万次比较，因此这样会使比较操作变成瓶颈的。另外，需要比较的局面数量多得惊人，要存储每个棋子的位置，需要占用非常大的空间。
　　一个解决方案是建立一个标签，通常是64位。由于64位不足以区别每个局面，所以仍然存在冲突的标签，但实战中这种情况非常罕见。
3.2 Zobrist键值的实现方法
　　实现Zobrist必须从多维的64位数组开始，每个数组含有一个随机数。在Java中，“rand.nextLong()”函数返回一个64位的随机数值。
这个函数用来填满一个long型（64位）的三维数组：棋子的类型、棋子的颜色和棋子的位置：
long zobrist[pcMAX][coMAX][sqMAX]; 
　 
　　程序启动时就把这个数组用随机数填满。要为一个局面产生Zobrist键值，首先把键值设成零，然后找棋盘上的每个子，并且让键值跟“zobrist[pc][co][sq]”做异或(通过“^”运算符)运算。 
　　如果局面由白方走，那么别去动它，如果是黑方走，你还要在键值上异或一个64位的随机常数。
3.3 Zobrist键值的工作原理及用途
3.3.1 Zobrist键值的工作原理
用Zobrist技术产生的键值，表面上跟局面没什么关系。如果一个棋子动过了，就会得到完全不同的键值，所以这两个键值不会挤在一块儿或者冲突。当把它们用作散列表键值的时候会非常有效。 
　　另一个优点在于，键值的产生是可以逐步进行的。例如，红马在e5格，那么键值里一定异或过一个“zobrist[KNIGHT][RED][E5]”。如果再次异或这个值，那么根据异或的工作原理，这个马就从键值里删除了。 
　　这就是说，如果有当前局面的键值，并且需要把红马从e5移到f7，你只要异或一个“红马在e5”的键值，把马从e5格移走，并且异或一个“红马在f7”的键值，把红马放在f7上。比起从头开始一个个棋子去异或，这样做可以得到同样的键值。
　　如果要改变着子的一方，只要异或一个“改变着子方”的键值就可以了。用这种方法，可以在搜索根结点的时候构造一个Zobrist键值，在搜索时通过走子函数“MakeMove()”来更新键值，一直让它保持和当前局面同步。 
3.3.2 Zobrist键值的用途
Zobrist键值通常用在散列键值当中，而散列键值在象棋程序里有以下几个作用：
　　1、用Zobrist键值来实现置换表。置换表是一个巨大的散列表，来保存以前搜索过的局面，这样可以节省很多搜索的时间。如果需要对某个局面搜索9层，可以从置换表中查找该局面，如果它已经搜索过9层，那么不必去重复搜索。置换表的另一个并不起眼的作用是，它可以帮助我们改善着法的顺序。
　　2、可以用Zobrist键值制造一个很小的散列表，来检测当前着法路线中有没有重复局面，以便发现长将或其他导致和局的着法。 
    3、可以用Zobrist键值创建支持置换的开局库。 
3.4 Java中实现Zobrist键值
本系统使用一个key和一个lock结合来区分每个局面，这样发生冲突（即两个局面对应的key和lock一样）的概率几乎为0。示例代码及相关说明如下
1、填充数组。
上述的三维数组现在改变为二维（将颜色与棋子兵种类型合并）
	……
public static long ZobristKeyPlayer;//改变走子方的key
	public static long ZobristLockPlayer;//改变走子方的lock
	public static long[][] ZobristKeyTable = new long[14][90];
	public static long[][] ZobristLockTable = new long[14][90];
	……
	static{
		……
		zobristGen();
}
	public static void zobristGen() {
		int i, j;
		Random rand = new Random();
long RandSeed;
		RandSeed = 1;
		rand.setSeed(RandSeed);
		ZobristKeyPlayer = rand.nextLong();
		for (i = 0; i < 14; i ++) {
		//0：红帅1：红仕2：红相3：红马4：红车5：红炮6：红兵
		//7：黑将8：黑士9：黑象10：黑马11：黑车12：黑炮13：黑卒
			for (j = 0; j < 90; j ++) {
				ZobristKeyTable[i][j] = rand.nextLong();
			}
		}
		ZobristLockPlayer = rand.nextLong();
		for (i = 0; i < 14; i ++) {
			for (j = 0; j < 90; j ++) {
				ZobristLockTable[i][j] = rand.nextLong();
			}
		}
	}
	
2、移子函数
当移动（添加、删除）一个棋子时，将当前局面的Zobrist键值与键值表中该棋子的键值进行异或操作，同时也与改变走子方的键值进行异或操作。
	public class ChessPosition{
		long ZobristKey, ZobristLock;
//当前局面的zobrist键值
		public ChessPosition{
			……
ZobristKey=0;//初始化为0
ZobristLock=0;
……
}
		……
public void makeMove(int Square, int Piece, boolean IsAdd) {
			……
			ZobristKey^=ZobristKeyTable[PieceType][Square];
ZobristLock^=ZobristLockTable[PieceType][Square];
ZobristKey ^= ZobristKeyPlayer;//改变走子方
ZobristLock ^= ZobristLockPlayer;
……
		}
	}
3、开局库：开局库的实现，将在“搜索方法”中说明。
第四章 着法生成
着法生成在不同的象棋引擎中差异较大。本章使用位棋盘生成着法的基本原理。高级的国际象棋引擎通常具备一次只生成一小部分着法的能力。例如，仅生成象走的着法，马走的着法，“将”的着法，所有的吃子着法等等，这正是位棋盘的强项。那为什么用这种方式生成着法呢？原因是生成着法耗费一定的时间。如果引擎在检查了一部分着法后发现了必须走的棋，那它就无需生成余下的棋步了。因此，可能先生成所有吃子的着法，如果没有满意的棋再生成余下的着法。(用来减少耗时的着法生成策略很多——发挥你的想象力吧)。 
大名鼎鼎的免费国际象棋引擎Crafty(其作者是Robert Hyatt博士)使用三个着法生成函数。一个用来生成所有伪合法吃子着法，一个生成所有伪合法不吃子着法，最后一个生成所有摆脱被将军状态的着法。注意前两个函数生成的是伪合法的着法。就是说，这些函数生成的着法并非都是合法的。例如，你要生成所有将军的着法并且发现了一步你想走的棋，但随后发现这步不合法再把它抛弃。这看起来很奇怪，但它确实比那种在所有局面下都严格生成合法着法的策略更快！Hyatt博士曾经这样解释：当国王被将时，你需要生成摆脱被将的着法，这时大部分生成的着法是不合法的，在这种局面中你使用生成所有合法着法的策略会帮你节省时间；但在大多数局面中，生成的着法都是合法的，推迟验证合法性会更有效率。
中国象棋的着法生成与此类似，先生成所有伪合法的着法，存入静态数组中。在对局中可以用“查表”的方式查找生成的伪着法，并对其合法性作出判断。这样可以节省大量的时间。
4.1伪合法着法的生成
伪合法着法包含几类：
各兵种的不吃子着法
各兵种的吃子着法
“将”和摆脱“将”的着法
其中，马、相（象）、兵、帅（将）、仕（士）的吃子着法与其对应的不吃子着法规则相同。（伪合法着法并不考虑被吃的棋子的颜色——该棋子是对方的棋子还是己方的棋子，也不考虑该子是否能动，例如动了该子，双方的帅将会面。）炮和车的不吃子着法规则相同，但分为纵向横向行走两类。炮的吃子着法分为纵向和横向两类，车的吃子着法也分为纵向和横向两类。马和象的着法要考虑蹩马腿和塞象眼。将军的着法单独作为一类。
本程序使用静态数组存储生成的位合法着法，先对其作一些说明。
  
