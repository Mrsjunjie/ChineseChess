# ChineseChess
  中国象棋使用
  的算法
  
  
  .2.3 Alpha-Beta修剪算法的实现
Alpha-Beta修剪算法在搜索中传递两个值，第一个值是Alpha，即搜索到的最好值，任何比它更小的值就没用了，因为策略就是知道Alpha的值，任何小于或等于Alpha的值都不会有所提高。 
第二个值是Beta，即对于对手来说最坏的值。这是对手所能承受的最坏的结果，因为我们知道在对手看来，他总是会找到一个对策不比Beta更坏的。如果搜索过程中返回Beta或比Beta更好的值，那就够好的了，走棋的一方就没有机会使用这种策略了。
在搜索着法时，每个搜索过的着法都返回跟Alpha和Beta有关的值，它们之间的关系非常重要，或许意味着搜索可以停止并返回。
如果某个着法的结果小于或等于Alpha，那么它就是很差的着法，因此可以抛弃。因为我前面说过，在这个策略中，局面对走棋的一方来说是以Alpha为评价的。
如果某个着法的结果大于或等于Beta，那么整个结点就作废了，因为对手不希望走到这个局面，而它有别的着法可以避免到达这个局面。因此如果我们找到的评价大于或等于Beta，就证明了这个结点是不会发生的，因此剩下的合理着法没有必要再搜索。
如果某个着法的结果大于Alpha但小于Beta，那么这个着法就是走棋一方可以考虑走的，除非以后有所变化。因此Alpha会不断增加以反映新的情况。有时候可能一个合理着法也不超过Alpha，这在实战中是经常发生的，此时这种局面是不予考虑的，因此为了避免这样的局面，我们必须在博弈树的上一个层局面选择另外一个着法。算法代码如下，醒目斜体部分是在最小-最大算法上改过的：
int AlphaBeta(int depth, int alpha, int beta) { 
　if (depth == 0) { 
return Evaluate(); 
　} 
　GenerateLegalMoves(); 
　while (MovesLeft()) { 
　　MakeNextMove(); 
　　val = -AlphaBeta(depth - 1, -beta, -alpha); 
　　UnmakeMove(); 
　　if (val >= beta) { 
　　　return beta; 
　　} 
　　if (val > alpha) { 
　　　alpha = val; 
　　} 
　} 
　return alpha; 
} 
把醒目的部分去掉，剩下的就是最小-最大函数。可以看出现在的算法没有太多的改变。 
这个函数需要传递的参数有：需要搜索的深度，负无穷大即Alpha，以及正无穷大即Beta： 
val = AlphaBeta(5, -INFINITY, INFINITY); 
这样就完成了5层的搜索。最终出现的情况是，在搜索树的很多地方，Beta是很容易超过的，因此很多工作都免去了。 
5.2.4 可能的弱点
这个算法严重依赖于着法的寻找顺序。如果你总是先去搜索最坏的着法，那么Beta截断就不会发生，因此该算法就如同最小-最大一样，效率非常低。该算法最终会找遍整个博弈树，就像最小-最大算法一样。 
如果程序总是能挑最好的着法来首先搜索，那么数学上有效分枝因子就接近于实际分枝因子的平方根。这是Alpha-Beta算法可能达到的最好的情况。
 
